### 作用域

1.1编译原理

<ul>
    <li>引擎： javascript程序的编译及执行</li>
    <li>编译器：语法分析及代码生成</li>
    <li>作用域：收集并维护由所有声明的标识符（变量）组成的一系列查询</li>
</ul>
LHS查询（赋值操作的目标是谁）和RHS查询（谁是赋值操作的源头）

词法作用域
eval(..) / with 欺骗词法

隐藏内部实现

在函数作用域内部声明变量和函数，规避同名标识符之间的冲突

立即执行函数（IIFE）
    (function(){ .. })();
    第一个（）将函数转为表达式，第二个（）执行这个函数

let关键字   1.垃圾收集  2.let循环

const关键字 固定常量

javascript的执行  先编译再执行，最后从上而下（先声明后赋值）

函数声明和变量声明都会提升，函数优先提升

闭包作用域

(当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包)。

在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或者其他异步任务中，只要使用回调函数，实际上就是在使用闭包

循环和闭包
```javascript
for(var i=1; i<=5; i++) {
    setTimeout( function timer(){
        console.log(i);
    },i*1000);
}//6 6 6 6 6

for(var i=1; i<=5; i++) {
    (function() {
        setTimeout( function timer(){
            console.log(i);
        }, i*1000);
    })();
}//6 6 6 6 6 

for(var i=1; i<=5; i++) {
    (function(){
        var j=i;
        setTimeout( function timer() {
            console.log(j);
        },j*1000 );
    })();
}//1 2 3 4 5
```

模块

1.必须有外部的封闭函数，该函数必须至少被调用一次（每一次调用都会创建一个新的模块实例）；
2.封闭函数发安徽至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

动态作用域

作用域链是基于调用栈的，而不是代码中的作用域嵌套。

第二部分 this和对象原型

this 是在运行时绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

默认绑定

直接使用不带任何修饰的函数进行的调用应用 this 的默认绑定，this 指向全局对象。严格模式（strict mode）下，全局对象将无法使用默认绑定，此时 this 会绑定到 undefined。

注意：用到第三方库时，其严格程度可能有所不同，注意此类兼容性细节。

隐式绑定

当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象属性引用链中只有最后一层会影响调用位置（就近原则）。
