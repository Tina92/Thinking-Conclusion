### 作用域

1.1编译原理

<ul>
    <li>引擎： javascript程序的编译及执行</li>
    <li>编译器：语法分析及代码生成</li>
    <li>作用域：收集并维护由所有声明的标识符（变量）组成的一系列查询</li>
</ul>
LHS查询（赋值操作的目标是谁）和RHS查询（谁是赋值操作的源头）

词法作用域
eval(..) / with 欺骗词法

隐藏内部实现

在函数作用域内部声明变量和函数，规避同名标识符之间的冲突

立即执行函数（IIFE）
    (function(){ .. })();
    第一个（）将函数转为表达式，第二个（）执行这个函数

let关键字   1.垃圾收集  2.let循环

const关键字 固定常量

javascript的执行  先编译再执行，最后从上而下（先声明后赋值）

函数声明和变量声明都会提升，函数优先提升

闭包作用域

(当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包)。

在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或者其他异步任务中，只要使用回调函数，实际上就是在使用闭包

循环和闭包
```javascript
for(var i=1; i<=5; i++) {
    setTimeout( function timer(){
        console.log(i);
    },i*1000);
}//6 6 6 6 6

for(var i=1; i<=5; i++) {
    (function() {
        setTimeout( function timer(){
            console.log(i);
        }, i*1000);
    })();
}//6 6 6 6 6 

for(var i=1; i<=5; i++) {
    (function(){
        var j=i;
        setTimeout( function timer() {
            console.log(j);
        },j*1000 );
    })();
}//1 2 3 4 5
```

模块

1.必须有外部的封闭函数，该函数必须至少被调用一次（每一次调用都会创建一个新的模块实例）；
2.封闭函数发安徽至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。